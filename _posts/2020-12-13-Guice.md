---
layout: post
title:  Dependency Injection and Guice
comments: true
category: java
---

在看 Java 代码的时候，看到了 DI 和 Guice 相关的内容。
感觉不记录一下过段时间就又会忘记了，这篇就简单记录一下这两个东西。

# Dependency Injection (DI)

DI 是一种设计模式，是指类或函数，不主动创建（construct）依赖，而是 *依靠上层应用创建好依赖*， 然后 *以函数参数的形式接受这些依赖*。
在这个过程中，类或者函数失去了对自己依赖的管理，因此 DI 也被称为 Inversion of control (IoC)。

### Example

如下是**没有**使用 DI 的代码：

```java
class Foo {
    private Database database;
    Foo() {
        this.database = new Database("xxx");
    }
}
```

如果使用 DI 后，`database` 变量则以参数的形式接收：

```java
class Foo {
    private Database database;
    Foo(Database database) {
        this.database = database;
    }
}
```

那 DI 有啥好处？主要是解耦了类和类的依赖，实现了模块化，使得测试更加方便。
比如上面的 `Foo` 类，现在可以通过给不同的 `database` 值，来直接进行不同环境下的测试，比如 production database, test database 等。

# Guice

徒手写 DI 是可行的，但是如果碰到递归的依赖，代码写起来就难维护，比如上面的例子中 Database 可能本身又会有依赖。
因此一般需要一个框架来支持 DI 代码的编写。

[Guice](https://github.com/google/guice) 就是这样的一个框架，是一个支持在 Java 中更方便编写 DI 的工具。
其核心思想是维护一个类似 `Key -> class` 的**映射**（实际上会复杂一点），来记录每一个类的依赖。
在类的构造过程中，Guice 会通过类的特征（构造函数的参数）在映射中找到依赖，然后构建依赖进而构建并返回用户所要的类。

### Example

以下代码片段是使用 Guice 的例子，来自 Guice [官方文档](https://github.com/google/guice/wiki/Motivation)：

```java
// module, 维护映射的地方
public class BillingModule extends AbstractModule {
  @Override
  protected void configure() {
    bind(TransactionLog.class).to(DatabaseTransactionLog.class);
    bind(CreditCardProcessor.class).to(PaypalCreditCardProcessor.class);
    bind(BillingService.class).to(RealBillingService.class);
  }
}

// billing service, 应用所需要的类
public class RealBillingService implements BillingService {
  private final CreditCardProcessor processor;
  private final TransactionLog transactionLog;

  @Inject
  public RealBillingService(CreditCardProcessor processor,
      TransactionLog transactionLog) {
    this.processor = processor;
    this.transactionLog = transactionLog;
  }

  public Receipt chargeOrder(Order order, CreditCard creditCard) {
    // use processor and transactionLog to do things
  }
}

// 主函数
public static void main(String[] args) {
  Injector injector = Guice.createInjector(new BillingModule());
  BillingService billingService = injector.getInstance(BillingService.class);
}
```

`BillingModule` 即前文提到的映射关系，此处为 type -> type 的映射。
`main`函数中首先获得 `Guice Injector`（同时传给 injector 映射表），然后通过 injector 获得 `billingService`。
`RealBillingService` 中不再需要对依赖进行创建，只需要在构造函数中通过 annotation `@Inject` 来告诉 Guice 参数是需要被注入的依赖。

# Conclusion

本文介绍了 DI 和 Java 中的 DI 工具 Guice。
针对 Guice 介绍仅仅只说了为什么需要它以及大概是怎么样一个东西，具体的使用方式和实现原理还是需要再看[官方文档](https://github.com/google/guice/wiki/Motivation)啦。
文档非常详细，而且也包含了对 DI 的说明和介绍。